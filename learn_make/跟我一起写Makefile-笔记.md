# 2 makefile 介绍

# 3 书写规则

## 3.3 在规则中使用通配符

make 支持三个通配符：*, ? 和 ~。

波浪号（~）表示当前用户的 home目录。

\* 匹配任意长度的字符串

## 3.4 文件搜寻

在一些大的工程中，有大量的源文件，通常的做法是把这些源文件分类，并存放在不同的目录中。当 make 需要找寻文件的依赖关系时，可以在文件前加上路径，但最好的方法是把一个路径告诉 make, 让 make 自动去找。

Makefile 文件中的特殊变量 **VPATH** 就是完成这个功能的，如果没有指明这个变量，make 只会在当前的目录中去寻找依赖文件和目标文件。如果定义了这个变量，那么，make 就会在当前目录找不到的情况下，到所指定的目录中寻找文件了。

```makefile
VPATH = src:../headers
```

上面指定两个目录“src”和“../headers”，make 会按照这个顺序进行搜索。目录由冒号分隔，当前目录搜索优先级最高。

# 4 书写命令

## 4.1 显示命令

通常，make会把其要执行的命令在命令执行前输出到屏幕上。当我们在命令前面加上用 **@**，那么，这个命令不会被 make 显示出来。

如果 make 执行时，带有参数 -n 或者 --just-print，那么其只显示命令，但不会执行命令

而 make 参数 -s 或 --silent 或 --quiet则时全面禁止命令的显示。

# 4.3 命令出错

每当命令运行完后，make 会检测每个命令的返回码，如果命令返回成功，那么make会执行吓一跳命令，当规则中的所有命令成功返回后，这个规则就算是成功完成了。如果一个规则中某个命令出错了，那么make就会终止执行当前规则。

为在在命令出错后继续执行后续命令，可以在Makefile的命令前面加上一个减号 -，标记为不管命令处不出错都认为是成功的。

也可以给make加上 -i或者 --ignore-errors参数。

-k 或者 --keep-going：如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其他规则。

## 4.4 嵌套执行 make

在一些大的工程中，会把不同模块或者不同功能的源文件放在不同的目录中，可以在每一个目录中都书写一个该目录的Makefile。

例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明这个目录下文件的编译规则。

```makefile
subsystem:
    cd subdir &&(MAKE)
```

其等价于：

```makefile
subsystem:
    &(MAKE) -C subdir
```

定义 \$(MAKE)宏变量的原因是，也许make需要传递一些参数，所以定义成一个变量利于维护

 如果想要将变量传递到下级makefile中，可以在变量前加上 export。不想传递可以加unexport。

如果传递所有的变量，只要一个export就行了，后面什么都不跟，表示传递所有的变量。

SHELL和MAKEFLAGS两个变量无论是否export,总是会传递到下层makefile中

参数 -w会在进出目录时打印目录信息。

# 5 使用变量

变量的命名可以包含字符、数字、下划线。

变量大小写敏感

:= 只能使用前面已经定义好的变量。

?= 如果没有被定义过，就定义该变量，如果被定义过，这条语句就什么也不干。

+= 追加变量值

# 5.3 变量值的替换

可以替换变量中共有的部分，其格式是 \$(var:a=b)或者\${var:a=b}，含义是把变量 var 中以 a 字符串结尾的 a 替换成 b

# 6 条件判断

ifeq else  endif

ifneq


